#!/usr/bin/env python

from exec_trace import ExecTrace
OUTPUT_DIR = "output"
romset_dir = None

KNOWN_VARS = {}

def getVariableName(addr):
  if value in KNOWN_VARS.keys():
    return KNOWN_VARS[addr]
  else:
    return "0x%04X" % value

def get_label(addr):
  return "LABEL_%04X" % addr

class MSX_Trace(ExecTrace):
  def output_disasm_headers(self):
    header = "; Generated by MSX_ExecTrace\n"
    for var in KNOWN_VARS.keys():
      name = KNOWN_VARS[var]
      header += "%s\t\tEQU 0x%02X\n" % (name, var)
    return header

  def disasm_instruction(self, opcode):

    simple_instructions = {
      0x00: "nop",
      #0x02: "ld (bc), a",
      #0x03: "inc bc",
      #0x04: "inc b",
      0x07: "rlca",
      0x17: "rla",
    }

    if opcode in simple_instructions:
      return simple_instructions[opcode]

    elif opcode & 0xCF == 0x01: # ld ??, word
      STR = ['bc', 'de', 'hl', 'sp']
      immediate = self.fetch()
      immediate = immediate | (self.fetch() << 8)
      return "ld %s, 0x%04X" % (STR[(opcode >> 4) & 3], immediate)

    elif opcode & 0xCF == 0x06: # ld ??, byte
      STR = ['b', 'd', 'hl', '(hl)']
      immediate = self.fetch()
      return "ld %s, 0x%02X" % (STR[(opcode >> 4) & 3], immediate)

    elif opcode== 0x32: # 
      imm = self.fetch()
      imm = imm | (self.fetch() << 8)
      return "ld (0x%04X), a" % imm

    elif opcode & 0xF0 == 0x40: # ld b, ??
      STR = ['b', 'c', 'd', 'e', 'h', 'l', '(hl)', 'a']
      return "ld b, %s" % STR[opcode & 0x07]

    elif opcode & 0xF0 == 0xB0: # or ??
      STR = ['b', 'c', 'd', 'e', 'h', 'l', '(hl)', 'a']
      return "or %s" % STR[opcode & 0x07]

    elif opcode== 0xcd: # CALL
      addr = self.fetch()
      addr = addr | (self.fetch() << 8)
      self.subroutine(addr)
      return "call 0x%04X" % addr

    elif opcode== 0xed: # EXTENDED INSTRUCTIONS:
      ext_opcode = self.fetch()

      ext_instructions = {
        0xb0: "ldir",
      }
      if ext_opcode in ext_instructions:
        return ext_instructions[ext_opcode]
      else:
        self.illegal_instruction(0xed00 | opcode)
        return "; DISASM ERROR! Illegal extended instruction (opcode = 0x%02X)" % opcode

    else:
      self.illegal_instruction(opcode)
      return "; DISASM ERROR! Illegal instruction (opcode = 0x%02X)" % opcode

def makedir(path):
  if not os.path.exists(path):
    os.mkdir(path)

import os
import sys
if len(sys.argv) != 2:
  print("usage: {} <filename.rom>".format(sys.argv[0]))
else:
  gamerom = sys.argv[1]
  makedir(OUTPUT_DIR)
  print "disassembling {}...".format(gamerom)
  trace = MSX_Trace(gamerom, loglevel=0, relocation_address=0x0000)
  trace.run(entry_point=0x0010)
#  trace.print_ranges()
#  trace.print_grouped_ranges()

  trace.save_disassembly_listing("{}.asm".format(gamerom.split(".")[0]))
